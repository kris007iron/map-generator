/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/Sprite */ \"./src/modules/Sprite.ts\");\n/* harmony import */ var _modules_Board__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/Board */ \"./src/modules/Board.ts\");\n/* harmony import */ var _modules_SquareSelecting__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/SquareSelecting */ \"./src/modules/SquareSelecting.ts\");\n\n\n\nnew _modules_Board__WEBPACK_IMPORTED_MODULE_1__.PresetBoard(0, 0, _modules_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getSpriteWidth() / _modules_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getElementSize(), _modules_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getSpriteHeight() / _modules_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getElementSize());\nlet playBoard = new _modules_Board__WEBPACK_IMPORTED_MODULE_1__.CustomBoard((_modules_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getSpriteWidth() / 2 + _modules_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getSpriteWidth() / _modules_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getElementSize() / 2) + 10, 50, 18, 18);\n//SquareSelecting.getInstance();\n_modules_SquareSelecting__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getInstance().setSelectionBoard(playBoard);\n\n\n//# sourceURL=webpack://xix-generator_map/./src/index.ts?");

/***/ }),

/***/ "./src/modules/Board.ts":
/*!******************************!*\
  !*** ./src/modules/Board.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomBoard: () => (/* binding */ CustomBoard),\n/* harmony export */   PresetBoard: () => (/* binding */ PresetBoard),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Square__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Square */ \"./src/modules/Square.ts\");\n\n/**\n * Abstract class representing a generic Board.\n * @implements {BoardInt}\n */\nclass Board {\n    /**\n     * Creates an instance of Board.\n     * @param startX - The starting X coordinate.\n     * @param startY - The starting Y coordinate.\n     * @param width - The width of the board.\n     * @param height - The height of the board.\n     */\n    constructor(startX, startY, width, height) {\n        this.startX = startX;\n        this.startY = startY;\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * Adds a square to the board.\n     * @param square - The square to add.\n     */\n    pushSquare(square) {\n        this.squares.push(square);\n    }\n    /**\n     * Clears all squares from the board.\n     */\n    clearBoard() {\n        this.squares = [];\n    }\n    /**\n     * Sets all squares on the board to their default state.\n     */\n    setDefault() {\n        for (let i = 0; i < this.squares.length; i++) {\n            this.squares[i].setDefault();\n        }\n    }\n}\n/**\n * Class representing a board with preset squares.\n * @extends {Board}\n */\nclass PresetBoard extends Board {\n    /**\n     * Creates an instance of PresetBoard.\n     * @param startX - The starting X coordinate.\n     * @param startY - The starting Y coordinate.\n     * @param width - The width of the board.\n     * @param height - The height of the board.\n     */\n    constructor(startX, startY, width, height) {\n        super(startX, startY, width, height);\n        this.squares = [];\n        for (let i = 0; i < this.width; i++) {\n            for (let j = 0; j < this.height; j++) {\n                this.pushSquare(new _Square__WEBPACK_IMPORTED_MODULE_0__.PresetSquare(startX, startY, i, j));\n            }\n        }\n    }\n}\n/**\n * Class representing a board with custom squares.\n * @extends {Board}\n */\nclass CustomBoard extends Board {\n    /**\n     * Creates an instance of CustomBoard.\n     * @param startX - The starting X coordinate.\n     * @param startY - The starting Y coordinate.\n     * @param width - The width of the board.\n     * @param height - The height of the board.\n     */\n    constructor(startX, startY, width, height) {\n        super(startX, startY, width, height);\n        this.squares = [];\n        for (let i = 0; i < this.width; i++) {\n            for (let j = 0; j < this.height; j++) {\n                this.pushSquare(new _Square__WEBPACK_IMPORTED_MODULE_0__.CustomSquare(startX, startY, i, j));\n            }\n        }\n    }\n    /**\n     * Sets all custom squares on the board to their default state.\n     */\n    setDefault() {\n        for (let i = 0; i < this.squares.length; i++) {\n            this.squares[i].setDefault();\n        }\n    }\n    /**\n     * Clears all custom squares from the board.\n     */\n    clearBoard() {\n        for (let i = 0; i < this.squares.length; i++) {\n            this.squares[i].clear();\n        }\n        this.squares = [];\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Board);\n\n\n\n//# sourceURL=webpack://xix-generator_map/./src/modules/Board.ts?");

/***/ }),

/***/ "./src/modules/Operation.ts":
/*!**********************************!*\
  !*** ./src/modules/Operation.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Class representing an operation that can be part of a sequence of operations.\n * @implements {OperationInterface}\n */\nclass Operation {\n    /**\n     * Creates an instance of Operation.\n     * @param diff - The differences applied by this operation.\n     * @param previous - The previous operation in the sequence, if any.\n     */\n    constructor(diff, previous) {\n        this.previous = previous;\n        this.next = null;\n        this.diff = diff;\n    }\n    /**\n     * Gets the previous operation in the sequence.\n     * @returns The previous operation.\n     */\n    getPrevious() {\n        return this.previous;\n    }\n    /**\n     * Gets the next operation in the sequence.\n     * @returns The next operation.\n     */\n    getNext() {\n        return this.next;\n    }\n    /**\n     * Sets the next operation in the sequence.\n     * @param next - The next operation.\n     */\n    setNext(next) {\n        this.next = next;\n    }\n    /**\n     * Executes the operation on the given board and affected squares.\n     * @param selectionBoard - The board on which the operation is executed.\n     * @param affected - The squares affected by the operation.\n     */\n    execute(selectionBoard, affected) {\n        console.log(this.diff.changed);\n        for (let i = 0; i < selectionBoard.squares.length; i++) {\n            let sqaure = selectionBoard.squares[i];\n            let changed;\n            for (let j = 0; j < this.diff.changed.length; j++) {\n                if (this.diff.changed[j].windowOffset.x === sqaure.getWindowsOffset().x && this.diff.changed[j].windowOffset.y === sqaure.getWindowsOffset().y) {\n                    changed = this.diff.changed[j];\n                    sqaure.execute(changed);\n                }\n                for (let j = 0; j < affected.length; j++) {\n                    if (affected[j] === sqaure) {\n                        sqaure.calculateSpriteOffset(sqaure.getOffsetAsSelected());\n                    }\n                }\n            }\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Operation);\n\n\n//# sourceURL=webpack://xix-generator_map/./src/modules/Operation.ts?");

/***/ }),

/***/ "./src/modules/Sprite.ts":
/*!*******************************!*\
  !*** ./src/modules/Sprite.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Class representing a sprite with static properties for dimensions and path.\n */\nclass Sprite {\n    /**\n     * Gets the path to the sprite image.\n     * @returns The sprite image path.\n     */\n    static getSpritePath() {\n        return this.path;\n    }\n    /**\n     * Gets the width of the sprite.\n     * @returns The sprite width.\n     */\n    static getSpriteWidth() {\n        return this.spriteWidth;\n    }\n    /**\n     * Gets the height of the sprite.\n     * @returns The sprite height.\n     */\n    static getSpriteHeight() {\n        return this.spriteHeight;\n    }\n    /**\n     * Gets the size of individual elements within the sprite.\n     * @returns The element size.\n     */\n    static getElementSize() {\n        return this.elementSize;\n    }\n}\nSprite.spriteWidth = 1536;\nSprite.spriteHeight = 960;\nSprite.elementSize = 48;\nSprite.path = './src/gfx/sprites.png';\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sprite);\n\n\n//# sourceURL=webpack://xix-generator_map/./src/modules/Sprite.ts?");

/***/ }),

/***/ "./src/modules/Square.ts":
/*!*******************************!*\
  !*** ./src/modules/Square.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomSquare: () => (/* binding */ CustomSquare),\n/* harmony export */   PresetSquare: () => (/* binding */ PresetSquare),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ \"./src/modules/Sprite.ts\");\n/* harmony import */ var _SquareSelecting__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SquareSelecting */ \"./src/modules/SquareSelecting.ts\");\n\n\n/**\n * Abstract class representing a square.\n * @implements {SquareInt}\n * @abstract\n * @property {number} a - The size of the square.\n * @property {HTMLDivElement} div - The square's div element.\n * @property {number} left - The left offset of the square.\n * @property {number} top - The top offset of the square.\n * @property {number | undefined} leftImg - The left offset of the square's image.\n * @property {number | undefined} topImg - The top offset of the square's image.\n * @property {PreviousState} previousState - The previous state of the square.\n * @property {number} startX - The starting X coordinate.\n * @property {number} startY - The starting Y coordinate.\n * @property {number} x - The X coordinate.\n * @property {number} y - The Y coordinate.\n * @method getOffsetAsSelected - Gets the offset of the square when selected.\n * @method calculateSpriteOffset - Calculates the sprite offset for the square.\n * @method setDefault - Sets the square to its default state.\n * @method getWindowsOffset - Gets the window offset of the square.\n * @method runConstructor - Runs the constructor logic for the square.\n * @method getPos - Gets the position of the square.\n * @method execute - Executes changes on the square.\n * @method setPreviousState - Sets the square to its previous state.\n */\nclass Square {\n    /**\n     * Creates an instance of Square.\n     * @param startX - The starting X coordinate.\n     * @param startY - The starting Y coordinate.\n     * @param x - The X coordinate.\n     * @param y - The Y coordinate.\n     */\n    constructor(startX, startY, x, y) {\n        this.a = _Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getElementSize();\n        this.left = 0;\n        this.top = 0;\n        this.leftImg = undefined;\n        this.topImg = undefined;\n        this.previousState = { x: 0, y: 0, leftImg: undefined, topImg: undefined };\n        this.div = document.createElement('div');\n        this.startX = startX;\n        this.startY = startY;\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Sets the square to its default state.\n     */\n    setDefault() { }\n    /**\n     * Runs the constructor logic for the square.\n     */\n    runConstructor() { }\n    /**\n     * Gets the position of the square.\n     * @returns The position as a Point.\n     */\n    getPos() {\n        return { x: this.x, y: this.y };\n    }\n    /**\n     * Executes changes on the square.\n     * @param changes - The changes to apply.\n     */\n    execute(changes) {\n        if (changes.currentState && changes.currentState.x !== undefined && changes.currentState.y !== undefined && changes.currentState.x !== null && changes.currentState.y !== null) {\n            this.calculateSpriteOffset({ x: changes.currentState.x, y: changes.currentState.y });\n        }\n        else {\n            this.setDefault();\n        }\n        if (changes.previousState) {\n            this.previousState = { x: changes.previousState.x, y: changes.previousState.y, leftImg: changes.previousState.leftImg, topImg: changes.previousState.topImg };\n        }\n        else {\n            this.previousState = { x: 0, y: 0, leftImg: undefined, topImg: undefined };\n        }\n    }\n    /**\n     * Sets the square to its previous state.\n     */\n    setPreviousState() {\n        this.calculateSpriteOffset({ x: this.previousState.leftImg, y: this.previousState.topImg });\n    }\n}\n/**\n * Class representing a preset square.\n * @extends {Square}\n */\nclass PresetSquare extends Square {\n    /**\n     * Creates an instance of PresetSquare.\n     * @param startX - The starting X coordinate.\n     * @param startY - The starting Y coordinate.\n     * @param x - The X coordinate.\n     * @param y - The Y coordinate.\n     */\n    constructor(startX, startY, x, y) {\n        super(startX, startY, x, y);\n        this.x = x;\n        this.y = y;\n        this.startX = startX;\n        this.startY = startY;\n        this.left = (this.x * this.a) + this.startX;\n        this.top = (this.y * this.a) + this.startY;\n        if ((_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getSpriteWidth() / _Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getElementSize()) / 2 < this.x + 1) {\n            this.left = this.left - (_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getSpriteWidth() / _Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getElementSize() / 2) * this.a;\n            this.top = this.top + this.a * (_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getSpriteHeight() / _Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getElementSize());\n            this.left += this.startX;\n            this.top += this.startY;\n            this.left -= 16;\n            this.top += this.y + 20;\n        }\n        this.left += this.x;\n        this.top += this.y;\n        this.div.draggable = false;\n        this.calculateSpriteOffset();\n        this.div.classList.add('preset');\n        this.div.addEventListener('click', () => {\n            _SquareSelecting__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().clicked = this;\n            console.log(_SquareSelecting__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().selected);\n            if (_SquareSelecting__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().selected.length > 0) {\n                _SquareSelecting__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().selected.forEach((square) => {\n                    square.calculateSpriteOffset(_SquareSelecting__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().clicked.getOffsetAsSelected());\n                    square.div.classList.remove('selected');\n                });\n                if (!_SquareSelecting__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().autoNext) {\n                    _SquareSelecting__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().selected = [];\n                }\n                else {\n                    _SquareSelecting__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().setNextSquare();\n                }\n                _SquareSelecting__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getInstance().newOperation();\n            }\n        });\n        this.div.style.width = this.a + 'px';\n        this.div.style.height = this.a + 'px';\n        this.div.style.position = 'absolute';\n        this.div.style.left = this.left + 'px';\n        this.div.style.top = this.top + 'px';\n        document.body.appendChild(this.div);\n    }\n    /**\n     * Gets the offset of the square when selected.\n     * @returns The offset as a Point.\n     */\n    getOffsetAsSelected() {\n        return { x: this.leftImg, y: this.topImg };\n    }\n    /**\n     * Calculates the sprite offset for the square.\n     * @param customParams - Optional custom parameters for the offset.\n     */\n    calculateSpriteOffset(customParams) {\n        this.previousState = { x: this.x, y: this.y, leftImg: this.leftImg, topImg: this.topImg };\n        if (customParams) {\n            this.leftImg = customParams.x;\n            this.topImg = customParams.y;\n        }\n        else {\n            this.leftImg = this.x * this.a;\n            this.topImg = this.y * this.a;\n        }\n        this.div.style.backgroundImage = `url(${_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getSpritePath()})`;\n        this.div.style.backgroundPosition = `-${this.leftImg}px -${this.topImg}px`;\n    }\n    /**\n     * Gets the window offset of the square.\n     * @returns The window offset as a Point.\n     */\n    getWindowsOffset() {\n        return { x: this.left, y: this.top };\n    }\n}\n/**\n * Class representing a custom square.\n * @extends {Square}\n */\nclass CustomSquare extends Square {\n    /**\n     * Creates an instance of CustomSquare.\n     * @param startX - The starting X coordinate.\n     * @param startY - The starting Y coordinate.\n     * @param x - The X coordinate.\n     * @param y - The Y coordinate.\n     */\n    constructor(startX, startY, x, y) {\n        super(startX, startY, x, y);\n        this.x = x;\n        this.y = y;\n        this.startX = startX;\n        this.startY = startY;\n        this.left = (this.x * this.a) + this.startX;\n        this.top = (this.y * this.a) + this.startY;\n        if (x !== 0 || y !== 0) {\n            this.left -= x;\n            this.top -= y;\n        }\n        this.left += this.x;\n        this.top += this.y;\n        this.div.draggable = false;\n        this.div.style.backgroundColor = 'red';\n        this.div.style.pointerEvents = 'click';\n        this.div.style.userSelect = 'none';\n        this.div.style.width = this.a + 'px';\n        this.div.style.height = this.a + 'px';\n        this.div.style.position = 'absolute';\n        this.div.style.left = this.left + 'px';\n        this.div.style.top = this.top + 'px';\n        document.body.appendChild(this.div);\n    }\n    /**\n     * Gets the offset of the square when selected.\n     * @returns The offset as a Point.\n     */\n    getOffsetAsSelected() {\n        return { x: this.leftImg, y: this.topImg };\n    }\n    /**\n     * Calculates the sprite offset for the square.\n     * @param customParams - Optional custom parameters for the offset.\n     */\n    calculateSpriteOffset(customParams) {\n        if (customParams) {\n            this.previousState = { x: this.x, y: this.y, leftImg: this.leftImg, topImg: this.topImg };\n            if (customParams.x !== undefined && customParams.y !== undefined) {\n                this.leftImg = customParams.x;\n                this.topImg = customParams.y;\n            }\n            else {\n                this.setDefault();\n                return;\n            }\n        }\n        else {\n            this.leftImg = this.x * this.a;\n            this.topImg = this.y * this.a;\n        }\n        this.div.style.backgroundImage = `url(${_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getSpritePath()})`;\n        this.div.style.backgroundPosition = `-${this.leftImg}px -${this.topImg}px`;\n    }\n    /**\n     * Sets the square to its default state.\n     */\n    setDefault() {\n        this.div.style.backgroundImage = 'none';\n        this.previousState = { x: this.x, y: this.y, leftImg: this.leftImg, topImg: this.topImg };\n        this.leftImg = undefined;\n        this.topImg = undefined;\n    }\n    /**\n     * Gets the window offset of the square.\n     * @returns The window offset as a Point.\n     */\n    getWindowsOffset() {\n        return { x: this.left, y: this.top };\n    }\n    /**\n     * Clears the square.\n     */\n    clear() {\n        this.div.remove();\n    }\n    /**\n     * Runs the constructor logic for the square.\n     */\n    runConstructor() {\n        this.left = (this.x * this.a) + this.startX;\n        this.top = (this.y * this.a) + this.startY;\n        this.left += this.x;\n        this.top += this.y;\n        this.div.draggable = false;\n        this.div.style.backgroundColor = 'red';\n        this.div.style.pointerEvents = 'click';\n        this.div.style.userSelect = 'none';\n        this.div.style.width = this.a + 'px';\n        this.div.style.height = this.a + 'px';\n        this.div.style.position = 'absolute';\n        this.div.style.left = this.left + 'px';\n        this.div.style.top = this.top + 'px';\n        document.body.appendChild(this.div);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Square);\n\n\n\n//# sourceURL=webpack://xix-generator_map/./src/modules/Square.ts?");

/***/ }),

/***/ "./src/modules/SquareSelecting.ts":
/*!****************************************!*\
  !*** ./src/modules/SquareSelecting.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Square__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Square */ \"./src/modules/Square.ts\");\n/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sprite */ \"./src/modules/Sprite.ts\");\n/* harmony import */ var _Operation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Operation */ \"./src/modules/Operation.ts\");\n\n\n\n/**\n * Singleton class to handle square selecting operations.\n */\nclass SquareSelecting {\n    /**\n     * Private constructor to ensure Singleton pattern.\n     */\n    constructor() {\n        this.cached = [];\n        this.affected = [];\n        this.hovering = false;\n        this.spriteOffsets = [];\n        this.contextMenu = false;\n        this.selectedHelper = [];\n        this.selected = [];\n        this.control = false;\n        this.left = 0;\n        this.top = 0;\n        this.div = document.createElement('div');\n        this.div.style.position = 'absolute';\n        this.div.style.border = '1px solid black';\n        this.div.style.pointerEvents = 'none';\n        document.body.appendChild(this.div);\n        this.checkboxDiv = document.createElement('div');\n        this.checkboxDiv.style.position = 'absolute';\n        this.checkboxDiv.style.top = '0px';\n        this.checkboxDiv.style.left = _Sprite__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getSpriteWidth() / 4 * 3 + 'px';\n        this.checkboxDiv.style.width = \"350px\";\n        let text = document.createElement('p');\n        text.innerHTML = 'Auto select next square';\n        this.checkboxDiv.appendChild(text);\n        this.checkbox = document.createElement('input');\n        this.checkbox.type = 'checkbox';\n        this.checkbox.style.display = 'inline';\n        this.checkboxDiv.appendChild(this.checkbox);\n        document.body.appendChild(this.checkboxDiv);\n        this.checkbox.addEventListener('change', () => {\n            this.autoNext = this.checkbox.checked;\n        });\n        this.isSelecting = false;\n        document.addEventListener('mousedown', (e) => {\n            if (this.getConstraint(e) && !this.contextMenu && e.button === 0) {\n                if (!this.control) {\n                    for (let i = 0; i < this.selected.length; i++) {\n                        this.selected[i].div.classList.remove('selected');\n                    }\n                    this.selected = [];\n                }\n                this.isSelecting = true;\n                this.div.style.left = e.pageX + 'px';\n                this.div.style.top = e.pageY + 'px';\n                this.div.style.width = '0px';\n                this.div.style.height = '0px';\n                this.div.style.display = 'none';\n                //clicking functionality\n                this.left = e.pageX;\n                this.top = e.pageY;\n            }\n        });\n        document.addEventListener('mousemove', (e) => {\n            this.x = e.pageX;\n            this.y = e.pageY;\n            if (this.isSelecting && this.getConstraint(e)) {\n                if (e.pageX > this.left) {\n                    this.div.style.width = e.pageX - this.left + 'px';\n                }\n                else {\n                    this.div.style.left = e.pageX + 'px';\n                    this.div.style.width = this.left - e.pageX + 'px';\n                }\n                if (e.pageY > this.top) {\n                    this.div.style.height = e.pageY - this.top + 'px';\n                }\n                else {\n                    this.div.style.top = e.pageY + 'px';\n                    this.div.style.height = this.top - e.pageY + 'px';\n                }\n                this.div.style.display = 'block';\n                //make selecting\n                if (!this.control) {\n                    for (let i = 0; i < this.selected.length; i++) {\n                        this.selected[i].div.classList.remove('selected');\n                    }\n                    this.selected = [];\n                }\n                for (let i = 0; i < this.selectedHelper.length; i++) {\n                    this.selectedHelper[i].div.classList.remove('selected');\n                }\n                this.selectedHelper = [];\n                let leftD = parseInt(this.div.style.left);\n                let topD = parseInt(this.div.style.top);\n                let width = parseInt(this.div.style.width);\n                let height = parseInt(this.div.style.height);\n                let right = leftD + width;\n                let bottom = topD + height;\n                for (let i = 0; i < this.selectionBoard.squares.length; i++) {\n                    let square = this.selectionBoard.squares[i];\n                    let squareLeft = square.getWindowsOffset().x;\n                    let squareTop = square.getWindowsOffset().y;\n                    let squareRight = squareLeft + square.a;\n                    let squareBottom = squareTop + square.a;\n                    if (right > squareLeft && leftD < squareRight && bottom > squareTop && topD < squareBottom && !this.selected.includes(square)) {\n                        this.selectedHelper.push(square);\n                        square.div.classList.add('selected');\n                    }\n                }\n            }\n            this.pasteHovering(e);\n        });\n        document.addEventListener('mouseup', (e) => {\n            this.div.style.display = 'none';\n            this.div.style.width = '0px';\n            this.div.style.height = '0px';\n            this.selected.push(...this.selectedHelper);\n            this.affected = [];\n            this.isSelecting = false;\n            if (e.pageX === this.left && e.pageY === this.top && this.getConstraint(e) && this.selectedHelper.length === 0) {\n                for (let i = 0; i < this.selectionBoard.squares.length; i++) {\n                    let square = this.selectionBoard.squares[i];\n                    let squareLeft = square.getWindowsOffset().x;\n                    let squareTop = square.getWindowsOffset().y;\n                    let squareRight = squareLeft + square.a;\n                    let squareBottom = squareTop + square.a;\n                    if (e.pageX > squareLeft && e.pageX < squareRight && e.pageY > squareTop && e.pageY < squareBottom) {\n                        if (this.control) {\n                            if (this.selected.includes(square)) {\n                                let index = this.selected.indexOf(square);\n                                this.selected.splice(index, 1);\n                                square.div.classList.remove('selected');\n                            }\n                            else {\n                                this.selected.push(square);\n                                square.div.classList.add('selected');\n                            }\n                        }\n                        else {\n                            for (let i = 0; i < this.selected.length; i++) {\n                                this.selected[i].div.classList.remove('selected');\n                            }\n                            this.selected = [square];\n                            square.div.classList.add('selected');\n                        }\n                    }\n                }\n            }\n            if (this.hovering && this.getConstraint(e)) {\n                this.hovering = false;\n                this.newOperation();\n            }\n            //Check for unchecking with ctrl\n            this.selectedHelper = [];\n        });\n        document.addEventListener('keydown', (e) => {\n            if (e.metaKey) {\n                this.control = true;\n            }\n            else {\n                if (e.ctrlKey) {\n                    this.control = true;\n                }\n                else {\n                    this.control = false;\n                }\n            }\n            if (e.key === 'Delete') {\n                for (let i = 0; i < this.selected.length; i++) {\n                    this.selected[i].setDefault();\n                    this.selected[i].div.classList.remove('selected');\n                }\n                this.selected = [];\n            }\n            if (e.ctrlKey || e.metaKey) {\n                if (e.key === 'z') {\n                    this.undoOperation();\n                }\n                if (e.key === 'y') {\n                    e.preventDefault();\n                    this.redoOperation();\n                }\n                if (e.key === 'c') {\n                    this.copySelected();\n                }\n                if (e.key === 'x') {\n                    this.cutSelected();\n                }\n                if (e.key === 'v') {\n                    this.hovering = true;\n                    //clear selected\n                    for (let i = 0; i < this.selected.length; i++) {\n                        this.selected[i].div.classList.remove('selected');\n                    }\n                    this.selected = [];\n                    for (let i = 0; i < this.selectedHelper.length; i++) {\n                        this.selectedHelper[i].div.classList.remove('selected');\n                    }\n                    this.selectedHelper = [];\n                }\n                if (e.key === 's') {\n                    this.saveToFile();\n                }\n                if (e.key === 'l') {\n                    this.loadFromFile();\n                }\n            }\n        });\n        document.addEventListener('keyup', (e) => {\n            if (e.metaKey) {\n                this.control = false;\n            }\n            else {\n                if (e.ctrlKey) {\n                    this.control = false;\n                }\n                else {\n                    this.control = false;\n                }\n            }\n        });\n        document.getElementById('delete').addEventListener('click', () => {\n            for (let i = 0; i < this.selected.length; i++) {\n                this.selected[i].setDefault();\n                this.selected[i].div.classList.remove('selected');\n            }\n            this.selected = [];\n        });\n        document.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n            if (document.getElementById('contextmenu').style.display != 'flex' && this.getConstraint(e)) {\n                document.getElementById('contextmenu').style.display = 'flex';\n                this.contextMenu = true;\n            }\n            document.addEventListener('click', () => {\n                document.getElementById('contextmenu').style.display = 'none';\n                this.contextMenu = false;\n            });\n        });\n        document.addEventListener('scroll', () => {\n            document.getElementById('contextmenu').style.top = `${window.scrollY}px`;\n            document.getElementById('contextmenu').style.left = `${window.scrollX}px`;\n        });\n        document.getElementById('save').addEventListener('click', () => {\n            this.saveToFile();\n            //loading playBoard from json variable\n        });\n        document.getElementById('load').addEventListener('click', () => {\n            //loading playBoard from file\n            this.loadFromFile();\n        });\n        document.getElementById('cut').addEventListener('click', () => {\n            //cut selected squares, cache them and clear them from the board\n            this.cutSelected();\n        });\n        document.getElementById('copy').addEventListener('click', () => {\n            //copy selected squares\n            this.copySelected();\n        });\n        document.getElementById('paste').addEventListener('click', () => {\n            this.hovering = true;\n        });\n        document.getElementById('undo').addEventListener('click', () => {\n            this.undoOperation();\n        });\n        document.getElementById('redo').addEventListener('click', () => {\n            this.redoOperation();\n        });\n    }\n    /**\n     * Handle hovering paste operation.\n     * @param e - Mouse event\n     * @private\n     * @returns void\n     */\n    pasteHovering(e) {\n        //TODO: fix hovering with undo and redo\n        if (this.hovering && this.cached.length > 0 && this.getConstraint(e)) {\n            let notNullSquares = this.cached.filter((square) => square.getOffsetAsSelected().x !== undefined && square.getOffsetAsSelected().y !== undefined);\n            let lowestX;\n            let lowestY;\n            let highestY;\n            let highestX;\n            let cachedWidthPx;\n            let cachedHeightPx;\n            [lowestX, lowestY, highestX, highestY, cachedWidthPx, cachedHeightPx] = this.getCachedData();\n            let cachedWidth = Math.floor(cachedWidthPx / this.cached[0].a);\n            let cachedHeight = Math.floor(cachedHeightPx / this.cached[0].a);\n            let x = e.pageX;\n            let y = e.pageY;\n            for (let i = 0; i < this.affected.length; i++) {\n                this.affected[i].setPreviousState();\n            }\n            this.affected = [];\n            let unaffected = [...this.selectionBoard.squares];\n            for (let i = 0; i < this.spriteOffsets.length; i++) {\n                for (let j = 0; j < this.selectionBoard.squares.length; j++) {\n                    let square = this.selectionBoard.squares[j];\n                    let squareLeft = square.getWindowsOffset().x;\n                    let squareTop = square.getWindowsOffset().y;\n                    let squareRight = squareLeft + square.a;\n                    let squareBottom = squareTop + square.a;\n                    if (x > squareLeft && x < squareRight && y > squareTop && y < squareBottom) {\n                        if (this.spriteOffsets[i] === null) {\n                            square.setDefault();\n                            if (!this.affected.includes(square)) {\n                                this.affected.push(square);\n                                unaffected.splice(unaffected.indexOf(square), 1);\n                            }\n                        }\n                        else if (this.spriteOffsets[i].x !== undefined && this.spriteOffsets[i].y !== undefined && this.spriteOffsets[i].x !== null && this.spriteOffsets[i].y !== null) {\n                            square.calculateSpriteOffset(this.spriteOffsets[i]);\n                            if (!this.affected.includes(square)) {\n                                this.affected.push(square);\n                                unaffected.splice(unaffected.indexOf(square), 1);\n                            }\n                        }\n                    }\n                }\n                x += this.cached[0].a;\n                if (x > e.pageX + cachedWidthPx - this.cached[0].a) {\n                    x = e.pageX;\n                    y += this.cached[0].a;\n                }\n            }\n        }\n    }\n    /**\n     * Save current selection to a file.\n     */\n    saveToFile() {\n        let data = [...this.selectionBoard.squares];\n        let json = JSON.stringify(data);\n        let blob = new Blob([json], { type: 'application/json' });\n        let url = URL.createObjectURL(blob);\n        let a = document.createElement('a');\n        a.href = url;\n        a.download = 'board.json';\n        a.click();\n    }\n    /**\n     * Undo the last operation.\n     */\n    undoOperation() {\n        if (this.currentOperation.getPrevious()) {\n            console.log(\"undo operation\");\n            this.currentOperation = this.currentOperation.getPrevious();\n            this.currentOperation.execute(this.selectionBoard, this.affected);\n            //get mouse event and assign it to a variable\n            //get mouse position here\n            this.pasteHovering({ pageX: this.x, pageY: this.y });\n        }\n        console.log(this.currentOperation);\n    }\n    /**\n        * Redo the previously undone operation.\n    */\n    redoOperation() {\n        if (this.currentOperation.getNext()) {\n            console.log(\"redo operation\");\n            this.currentOperation = this.currentOperation.getNext();\n            this.currentOperation.execute(this.selectionBoard, this.affected);\n            this.pasteHovering({ pageX: this.x, pageY: this.y });\n        }\n        console.log(this.currentOperation);\n    }\n    /**\n     * Initialize a new operation.\n     */\n    newOperation() {\n        let diff = { changed: [] };\n        this.selectionBoard.squares.forEach((square) => {\n            diff.changed.push({ windowOffset: structuredClone(square.getWindowsOffset()), previousState: structuredClone(square.previousState), currentState: structuredClone(square.getOffsetAsSelected()) });\n        });\n        if (!this.currentOperation) {\n            console.log('first operation');\n            this.currentOperation = new _Operation__WEBPACK_IMPORTED_MODULE_2__[\"default\"](diff);\n        }\n        else {\n            console.log('new operation');\n            this.currentOperation.setNext(new _Operation__WEBPACK_IMPORTED_MODULE_2__[\"default\"](diff, this.currentOperation));\n            this.currentOperation = this.currentOperation.getNext();\n        }\n    }\n    /**\n     * Copy the currently selected squares.\n     */\n    copySelected() {\n        this.cached = [...this.selected];\n        this.spriteOffsets = [];\n        let lowestX;\n        let lowestY;\n        let highestX;\n        let highestY;\n        let cachedWidthPx;\n        let cachedHeightPx;\n        [lowestX, lowestY, highestX, highestY, cachedWidthPx, cachedHeightPx] = this.getCachedData();\n        let cachedWidth = Math.floor(cachedWidthPx / this.cached[0].a);\n        let cachedHeight = Math.floor(cachedHeightPx / this.cached[0].a);\n        let possible = [];\n        while (possible.length < cachedWidth * cachedHeight) {\n            possible.push({ x: lowestX, y: lowestY });\n            lowestX++;\n            if (lowestX > highestX) {\n                lowestX = lowestX - cachedWidth;\n                lowestY++;\n            }\n        }\n        for (let i = 0; i < possible.length; i++) {\n            if (this.cached.filter((square) => square.getPos().x === possible[i].x && square.getPos().y === possible[i].y).length > 0) {\n                let sqaure = this.cached.filter((square) => square.getPos().x === possible[i].x && square.getPos().y === possible[i].y)[0];\n                if (sqaure.getOffsetAsSelected().x !== undefined && sqaure.getOffsetAsSelected().y !== undefined)\n                    this.spriteOffsets.push(sqaure.getOffsetAsSelected());\n                else {\n                    this.spriteOffsets.push(null);\n                }\n            }\n            else {\n                this.spriteOffsets.push({ x: null, y: null });\n            }\n        }\n        this.selected.forEach((square) => {\n            square.div.classList.remove('selected');\n        });\n        this.selected = [];\n    }\n    /**\n     * Cut the currently selected squares.\n     */\n    cutSelected() {\n        this.cached = [...this.selected];\n        this.spriteOffsets = [];\n        let lowestX;\n        let lowestY;\n        let highestX;\n        let highestY;\n        let cachedWidthPx;\n        let cachedHeightPx;\n        [lowestX, lowestY, highestX, highestY, cachedWidthPx, cachedHeightPx] = this.getCachedData();\n        let cachedWidth = Math.floor(cachedWidthPx / this.cached[0].a);\n        let cachedHeight = Math.floor(cachedHeightPx / this.cached[0].a);\n        let possible = [];\n        while (possible.length < cachedWidth * cachedHeight) {\n            possible.push({ x: lowestX, y: lowestY });\n            lowestX++;\n            if (lowestX > highestX) {\n                lowestX = lowestX - cachedWidth;\n                lowestY++;\n            }\n        }\n        for (let i = 0; i < possible.length; i++) {\n            if (this.cached.filter((square) => square.getPos().x === possible[i].x && square.getPos().y === possible[i].y).length > 0) {\n                let sqaure = this.cached.filter((square) => square.getPos().x === possible[i].x && square.getPos().y === possible[i].y)[0];\n                if (sqaure.getOffsetAsSelected().x !== undefined && sqaure.getOffsetAsSelected().y !== undefined)\n                    this.spriteOffsets.push(sqaure.getOffsetAsSelected());\n                else {\n                    this.spriteOffsets.push(null);\n                }\n            }\n            else {\n                this.spriteOffsets.push({ x: null, y: null });\n            }\n        }\n        this.selected.forEach((square) => {\n            square.div.classList.remove('selected');\n            square.setDefault();\n        });\n        this.selected = [];\n        this.newOperation();\n    }\n    /**\n     * Load selection from a file.\n     */\n    loadFromFile() {\n        let input = document.createElement('input');\n        input.type = 'file';\n        input.accept = 'application/json';\n        input.click();\n        input.addEventListener('change', () => {\n            let file = input.files[0];\n            let reader = new FileReader();\n            reader.readAsText(file);\n            reader.onload = () => {\n                let data = JSON.parse(reader.result);\n                this.selectionBoard.clearBoard();\n                data.forEach((square) => {\n                    this.selectionBoard.pushSquare(new _Square__WEBPACK_IMPORTED_MODULE_0__.CustomSquare(square.startX, square.startY, square.x, square.y));\n                    if (square.leftImg && square.topImg) {\n                        this.selectionBoard.squares[this.selectionBoard.squares.length - 1].calculateSpriteOffset({ x: square.leftImg, y: square.topImg });\n                    }\n                    else {\n                        this.selectionBoard.squares[this.selectionBoard.squares.length - 1].setDefault();\n                    }\n                });\n                this.currentOperation = null;\n                this.newOperation();\n            };\n        });\n        console.log(this.currentOperation);\n    }\n    /**\n     * Get the instance of SquareSelecting, ensuring Singleton pattern.\n     * @returns Instance of SquareSelecting\n     */\n    static getInstance() {\n        if (!this.instance) {\n            this.instance = new SquareSelecting();\n        }\n        return this.instance;\n    }\n    /**\n     * Set the selection board.\n     * @param board - Board to set as selection board\n     * @returns void\n     * @public\n     * @memberof SquareSelecting\n     * @instance\n     * @method\n     * @this SquareSelecting\n     */\n    setSelectionBoard(board) {\n        this.selectionBoard = board;\n        let diffForDefault = { changed: [] };\n        for (let i = 0; i < this.selectionBoard.squares.length; i++) {\n            let square = this.selectionBoard.squares[i];\n            diffForDefault.changed.push({ windowOffset: square.getWindowsOffset(), previousState: square.previousState, currentState: { x: null, y: null } });\n        }\n        this.currentOperation = new _Operation__WEBPACK_IMPORTED_MODULE_2__[\"default\"](diffForDefault);\n    }\n    /**\n     * Check if the mouse event is within the constraints of the selection board.\n     * @param e - Mouse event\n     * @returns Boolean indicating if the event is within constraints\n     */\n    getConstraint(e) {\n        return e.pageX > this.selectionBoard.squares[0].getWindowsOffset().x && e.pageX < this.selectionBoard.squares[this.selectionBoard.squares.length - 1].getWindowsOffset().x + this.selectionBoard.squares[this.selectionBoard.squares.length - 1].a && e.pageY > this.selectionBoard.squares[0].getWindowsOffset().y && e.pageY < this.selectionBoard.squares[this.selectionBoard.squares.length - 1].getWindowsOffset().y + this.selectionBoard.squares[this.selectionBoard.squares.length - 1].a;\n    }\n    /**\n     * Get the bottom right square of the last selected square.\n     * @returns Bottom right square of the last selected square\n     * @public\n     * @memberof SquareSelecting\n     * @instance\n     * @method\n     * @this SquareSelecting\n     * @returns {Square} - Bottom right square of the last selected square\n     */\n    getBottomRightLastSelected() {\n        let pos = 0;\n        let square;\n        if (this.selected.length > 1) {\n            //get largest x and y and return this Square\n            for (let i = 0; i < this.selected.length; i++) {\n                let j = this.selectionBoard.squares.indexOf(this.selected[i]);\n                let help = j % Math.sqrt(this.selectionBoard.squares.length);\n                if (pos < help) {\n                    pos = help;\n                    square = this.selected[i];\n                }\n                else if (pos === help) {\n                    if (this.selectionBoard.squares.indexOf(square) < j) {\n                        square = this.selected[i];\n                    }\n                }\n            }\n        }\n        else {\n            square = this.selected[0];\n        }\n        return square;\n    }\n    /**\n     * Set the next square.\n     * @returns void\n     * @public\n     * @memberof SquareSelecting\n     */\n    setNextSquare() {\n        if (this.autoNext) {\n            let nextSquare = this.getNextSquare(this.getBottomRightLastSelected());\n            nextSquare.div.classList.add('selected');\n            this.selected = [nextSquare];\n        }\n    }\n    /**\n     * Get the next square.\n     * @param sqaure - Square to get the next square from\n     * @returns Next square\n     * @public\n     * @memberof SquareSelecting\n     */\n    getNextSquare(sqaure) {\n        for (let i = 0; i < this.selectionBoard.squares.length; i++) {\n            if (sqaure === this.selectionBoard.squares[i]) {\n                if (i != this.selectionBoard.squares.length - 1) {\n                    let next = i + Math.sqrt(this.selectionBoard.squares.length);\n                    if (next < this.selectionBoard.squares.length) {\n                        return this.selectionBoard.squares[next];\n                    }\n                    else {\n                        let help = i % Math.sqrt(this.selectionBoard.squares.length);\n                        next = help + 1;\n                        return this.selectionBoard.squares[next];\n                    }\n                }\n                else {\n                    return this.selectionBoard.squares[0];\n                }\n            }\n        }\n    }\n    /**\n     * setter for affected\n     * @param affected\n     * @returns void\n     * @public\n     * @memberof SquareSelecting\n     */\n    setAffected(affected) {\n        this.affected = affected;\n    }\n    /**\n     *gets data from cached\n     * @returns Array of cached data\n     * @public\n     * @memberof SquareSelecting\n     */\n    getCachedData() {\n        let lowestX = this.cached.filter((square) => square.getPos().x === Math.min(...this.cached.map((square) => square.getPos().x)))[0].getPos().x;\n        let lowestY = this.cached.filter((square) => square.getPos().y === Math.min(...this.cached.map((square) => square.getPos().y)))[0].getPos().y;\n        let highestX = this.cached.filter((square) => square.getPos().x === Math.max(...this.cached.map((square) => square.getPos().x)))[0].getPos().x;\n        let highestY = this.cached.filter((square) => square.getPos().y === Math.max(...this.cached.map((square) => square.getPos().y)))[0].getPos().y;\n        let cachedWidthPx = Math.abs(lowestX - highestX) * this.cached[0].a + this.cached[0].a;\n        let cachedHeightPx = Math.abs(lowestY - highestY) * this.cached[0].a + this.cached[0].a;\n        return [lowestX, lowestY, highestX, highestY, cachedWidthPx, cachedHeightPx];\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SquareSelecting);\n\n\n//# sourceURL=webpack://xix-generator_map/./src/modules/SquareSelecting.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;